# 핸들러
서버에서 핸들러를 어떻게 다루고 있는지 이런 구조를 왜 하였는지 등 기술했습니다.


## 핸들러란
클라이언트에서 전송한 요청에 대해 처리를 담당하는 요소입니다.


## 반환 규칙

1. 각 핸들러는 src/handlers/result.js의 Class Result를 규격으로 결과를 반환합니다.
2. 만약 null이나 undefined와 같은 빈 값을 반환시 OnData는 클라이언트로 응답을 반환하지 않습니다. 이는 응답이 필요없는 핸들러를 위해 추가한 규칙입니다.
3. Error가 인식되면 에러코드에 맞는 Result를 생성해 결과를 반환합니다.


## 핸들러 등록 규칙
1. 프로토버퍼 메세지를 우선 로드해야합니다.
2. 등록된 프로토버퍼의 "Package.Message"를 키 값으로 하며 알파벳 순서로 handlerId를 부여받습니다.
3. handlers/index.js에서 handlers하위의 디렉토리를 재귀탐색하며 "Package/Message.js"의 파일을 로드하여 등록합니다.
4. 만약 없다면 function을 제외한 나머지 정보들만 등록합니다.

### 이런 자동 등록 규칙을 사용해본 이유

순전히 호기심의 영역으로 적용해봤습니다. ID값이아닌 "Package.Message"를 키값으로 코드작업을 할 수 있으면 어떨까 라는 아이디어에서 시작하였지만, 많은 문제를 야기할 수 있음을 느꼈습니다.

첫번째로 어쩔 수 없이 문자열로 처리를 해야하는 상황이 발생하면 휴먼에러를 회피하기 어렵습니다.
두번째로 유연한 핸들러 등록이 어렵습니다.
세번째로 보안문제를 겪을 확률도 있을 것 같습니다. (유연치 못하기에 외부에서 HandlerId와 Packet을 알면 충분히 시도해볼만 할 것 같습니다.)

기존에 ID와 핸들러를 수동으로 등록하는 방식을 사용할만 한 이유를 알았습니다. 

### 그래도 겪었던 장점

1. 동적으로 불러오므로 항상 균등한 핸들러 ID를 갖출 수 있습니다.
2. 수동으로 기입할 필요 없어 비즈니스 로직에 집중할 수 있습니다.
3. 프로토버퍼와 같은 key값을 공유할 수 있게됩니다.

단점 : 그 외 전부

